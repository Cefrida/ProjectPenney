import numpy as np
import matplotlib.pyplot as plt
from src.helpers import PATH_DATA, debugger_factory
import random

HALF_DECK_SIZE = 26

@debugger_factory 
def get_decks(n_decks: int,
              seed: int, 
              half_deck_size: int = HALF_DECK_SIZE 
              ) -> tuple[np.ndarray, np.ndarray]:
    """
    Efficiently generate `n_decks` shuffled decks using NumPy.
    
    Returns:
        decks (np.ndarray): 2D array of shape (n_decks, num_cards), 
        each row is a shuffled deck.
    """
    init_deck = [0]*half_deck_size + [1]*half_deck_size
    decks = np.tile(init_deck, (n_decks, 1))
    rng = np.random.default_rng(seed)
    rng.permuted(decks, axis=1, out=decks)
    return decks

# Write a function that stores the data generated by get_decks()
#
# Make sure you can generate some decks, and then generate some additional decks
#   without losing track of the random seeds used.
#
# Make sure you can duplicate your results, i.e. get the exact same decks twice.

class DeckStorage:
    def __init__(self):
        self.decks = {}

    def add_decks(self, n_decks: int, seed: int):
        """
        Add new decks to the storage while keeping the old ones.
        """
        # Generate new decks
        new_decks = get_decks(n_decks, seed)
        
        # Store the decks using the seed as the key
        self.decks[seed] = new_decks
    
    def get_decks(self, seed: int):
        """
        Get the decks associated with a specific seed.
        """
        return self.decks.get(seed, None)
    
    def get_all_decks(self):
        """
        Retrieve all stored decks.
        """
        return self.decks

def generate_sequences():
    """
    Generate all possible sequences of 3 binary cards convert them to 'R' and 'B' labels.
    """
    binary_sequences = ['{:03b}'.format(i) for i in range(8)]
    rb_sequences = [seq.replace('0', 'B').replace('1', 'R') for seq in binary_sequences]
    return rb_sequences

